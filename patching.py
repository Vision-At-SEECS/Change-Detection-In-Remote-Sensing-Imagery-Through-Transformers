# -*- coding: utf-8 -*-
"""Patching2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XrDP-DbrDJYR0ivgJNs-Jnk3_Y6JSfB7
"""

from google.colab import drive
drive.mount('/content/drive')

pip install rasterio

import rasterio
img = rasterio.open('/content/drive/MyDrive/sentinel_2560/sentinel_1_2020.tif')
from matplotlib import pyplot
pyplot.imshow(img.read(2))
pyplot.show()

import rasterio
from rasterio.plot import show
from matplotlib import pyplot as plt
from rasterio import plot
import numpy as np
#to display RGB
dataset = rasterio.open('/content/drive/MyDrive/Change Maps Cropped/landcover_2.tif')
dataset.count



import rasterio
from rasterio.windows import Window
import os

def crop_tiff_to_size(tiff_path, output_path, target_size):
    with rasterio.open(tiff_path) as src:
        width = src.width
        height = src.height

        # Calculate cropping window
        start_x = (width - target_size) // 2
        start_y = (height - target_size) // 2
        window = Window(start_x, start_y, target_size, target_size)

        # Read data from window
        data = src.read(window=window)

        # Update metadata for new size
        kwargs = src.meta.copy()
        kwargs.update({
            'height': target_size,
            'width': target_size,
            'transform': src.window_transform(window)
        })

        # Write cropped data to new file
        with rasterio.open(output_path, 'w', **kwargs) as dst:
            dst.write(data)

        print(f"Cropped TIFF saved to {output_path}")

# Directory paths
input_directory = '/content/drive/MyDrive/Change Maps/'
output_directory = '/content/drive/MyDrive/Change Maps Cropped/'

# Ensure output directory exists
os.makedirs(output_directory, exist_ok=True)

# Target size
target_size = 2560

# Loop through all files from landcover_1 to landcover_9
for i in range(1, 10):  # Adjust range if needed
    original_tiff_path = os.path.join(input_directory, f'landcover_{i}.tif')
    cropped_tiff_path = os.path.join(output_directory, f'landcover_{i}.tif')

    if os.path.exists(original_tiff_path):  # Check if the file exists
        crop_tiff_to_size(original_tiff_path, cropped_tiff_path, target_size)
    else:
        print(f"File not found: {original_tiff_path}")

import os
import glob

# Define the directory path
directory_path = '/content/drive/MyDrive/LEVIR-CD'

# Find all files in the directory with "patch" in their names
files_to_delete = glob.glob(os.path.join(directory_path, '*patch*'))

# Loop through the files and delete each one
for file_path in files_to_delete:
    try:
        os.remove(file_path)
        print(f"Deleted: {file_path}")
    except Exception as e:
        print(f"Error deleting {file_path}: {e}")

from rasterio.windows import Window
from PIL import Image
import numpy as np
import os

patch_size = 256  # Patch size in pixels

def create_png_patches(tiff_path, output_dir, patch_size,image_num):
    with rasterio.open(tiff_path) as src:
        width = src.width
        height = src.height

        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)

        # Calculate number of patches
        num_patches_x = int(np.ceil(width / patch_size))
        num_patches_y = int(np.ceil(height / patch_size))

        for i in range(num_patches_x):
            for j in range(num_patches_y):
                # Calculate the window coordinates
                window = Window(i * patch_size, j * patch_size, patch_size, patch_size)
                # Read the patch data
                patch_data = src.read(window=window)

                # Print the dimensions of the patch
                patch_height, patch_width = patch_data.shape[1], patch_data.shape[2]
                print(f"Patch {i}_{j} dimensions: {patch_width}x{patch_height}")

                # Convert the patch to an image format
                patch_data = np.moveaxis(patch_data, 0, -1)  # Convert from (bands, height, width) to (height, width, bands)

                # If patch_data has more than 3 bands, take only the first 3 for RGB
                if patch_data.shape[2] > 3:
                    patch_data = patch_data[:, :, :3]

                # Convert to 8-bit image (0-255) if necessary
                if patch_data.dtype != np.uint8:
                    patch_data = np.uint8(patch_data / np.max(patch_data) * 255)

                # Create and save the patch image
                patch_image = Image.fromarray(patch_data)
                patch_filename = os.path.join(output_dir, f"patch_{image_num}_{i}_{j}.png")
                patch_image.save(patch_filename)
                print(f"Saved {patch_filename}")

tiff_path = '/content/drive/MyDrive/sentinel_2560_cropped/sentinel_1_2020.tif'

output_dir = '/content/drive/MyDrive/data_2560/A'
create_png_patches(tiff_path, output_dir, patch_size,1)

tiff_path = '/content/drive/MyDrive/ROI_7680/image_cropped_2021.tif'
output_dir = '/content/data_7680/B'
create_png_patches(tiff_path, output_dir, patch_size)



def load_landcover(file_path):
    with rasterio.open(file_path) as src:
        landcover_data = src.read()  # Read all bands
        transform = src.transform
    return landcover_data, transform

# Load landcover data for 2020 and 2021
landcover_2020, transform_2020 = load_landcover('/content/drive/MyDrive/landcovers_7680/landcover_cropped_2020.tif')
landcover_2021, transform_2021 = load_landcover('/content/drive/MyDrive/landcovers_7680/landcover_cropped_2021.tif')

array = np.abs(landcover_2021-landcover_2020)

array

landcover_2020.shape

import numpy as np
from PIL import Image
import os

def save_labels_for_patches(patch_size, output_labels_dir, change_labels):
    # Remove the band dimension if it exists
    if len(change_labels.shape) == 3:
        change_labels = np.squeeze(change_labels, axis=0)

    num_patches_x = int(np.ceil(change_labels.shape[1] / patch_size))
    num_patches_y = int(np.ceil(change_labels.shape[0] / patch_size))

    os.makedirs(output_labels_dir, exist_ok=True)

    for i in range(num_patches_x):
        for j in range(num_patches_y):
            x_start = i * patch_size
            x_end = min((i + 1) * patch_size, change_labels.shape[1])
            y_start = j * patch_size
            y_end = min((j + 1) * patch_size, change_labels.shape[0])

            patch_labels = change_labels[y_start:y_end, x_start:x_end]

            # Convert to binary change map: 255 for change, 0 for no change
            patch_labels_binary = np.where(patch_labels > 0, 255, 0).astype(np.uint8)

            patch_image = Image.fromarray(patch_labels_binary, mode='L')  # 'L' mode for grayscale images

            patch_filename = os.path.join(output_labels_dir, f"label_{i}_{j}.png")
            patch_image.save(patch_filename)
            print(f"Saved {patch_filename}")

def generate_change_labels(landcover_2020, landcover_2021):
    if len(landcover_2020.shape) == 3:
        landcover_2020 = np.squeeze(landcover_2020, axis=0)
    if len(landcover_2021.shape) == 3:
        landcover_2021 = np.squeeze(landcover_2021, axis=0)

    # Calculate change labels (difference between the two landcovers)
    change_labels = np.abs(landcover_2021 - landcover_2020)

    return change_labels

# Generate change labels
change_labels = generate_change_labels(landcover_2020, landcover_2021)

# Save labels for patches with binary representation
save_labels_for_patches(256, 'labels_7680/', change_labels)

import PIL
PIL.Image.open('/content/data_7680/A/patch_0_0.png')

PIL.Image.open('/content/data_7680/B/patch_0_0.png')

PIL.Image.open('/content/labels_7680/label_0_0.png')

import rasterio
import numpy as np
from PIL import Image
import os

# Function to generate patches from the image
def create_patches(image, patch_size=256):
    patches = []
    height, width = image.shape

    # Loop through the image to create patches
    for i in range(0, height, patch_size):
        for j in range(0, width, patch_size):
            patch = image[i:i+patch_size, j:j+patch_size]
            if patch.shape == (patch_size, patch_size):  # Ensure patch size is correct
                patches.append((i // patch_size, j // patch_size, patch))  # Save patch with its indices
    return patches

# Function to normalize and save patches in the specified format
def save_patches(patches, label, output_dir):
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    for i, j, patch in patches:
        # Normalize the patch data to 0-255 and convert to uint8
        patch_normalized = ((patch - patch.min()) / (patch.max() - patch.min()) * 255).astype(np.uint8)

        patch_img = Image.fromarray(patch_normalized)
        patch_path = os.path.join(output_dir, f"{label}_{i}_{j}.png")
        patch_img.save(patch_path)
        print(f'Saved {patch_path}')

# Directory containing your TIFF files
tiff_files = [f'/content/drive/MyDrive/Change Maps Cropped/landcover_{i}.tif' for i in range(1,10)]

# Process each land cover file
for cover_index, tiff_file in enumerate(tiff_files, start=1):
    with rasterio.open(tiff_file) as src:
        image = src.read(1)  # Read the single band image

    # Create patches for the current image
    patches = create_patches(image)

    # Define output directory and label for current land cover
    output_dir = "/content/drive/MyDrive/LEVIR-CD/newLabels"

    # Save the patches
    save_patches(patches, cover_index, output_dir)

import PIL
PIL.Image.open('/content/drive/MyDrive/LEVIR-CD/newLabels/2_0_0.png')

img = Image.open('/content/drive/MyDrive/LEVIR-CD/B/patch_1_0_0.png')
mode =img.mode
print(mode, img.getbands())

img = Image.open('/content/drive/MyDrive/STANet/dataset/train/A/train_1.png')
print(img.size)

img = Image.open('/content/drive/MyDrive/BIT_CD_1/samples/A/test_102_0512_0000.png')
img.size

img = Image.open('/content/drive/MyDrive/label_400_entries/patch_1_0_0.png')
print(img.mode)

